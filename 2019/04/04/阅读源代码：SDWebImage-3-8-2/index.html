<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="旧文章迁移自：简书 create by 2017.01.24 08:45 简单的介绍SDWebImage 提供图片的异步下载和缓存，对外通过 categories 封装 UIImageView ，UIButton，MKAnnotationView 的接口供使用者使用。SDWebImage 的磁盘缓存有对有效期和最大容量的限制处理，内存缓存在系统报内存警告的时候会清除。它还保障几个相同的 URL 不">
<meta name="keywords" content="Java, iOS, Web">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读源代码：SDWebImage 3.8.2">
<meta property="og:url" content="https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/index.html">
<meta property="og:site_name" content="刘海川的技术博客">
<meta property="og:description" content="旧文章迁移自：简书 create by 2017.01.24 08:45 简单的介绍SDWebImage 提供图片的异步下载和缓存，对外通过 categories 封装 UIImageView ，UIButton，MKAnnotationView 的接口供使用者使用。SDWebImage 的磁盘缓存有对有效期和最大容量的限制处理，内存缓存在系统报内存警告的时候会清除。它还保障几个相同的 URL 不">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-04T09:47:30.024Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阅读源代码：SDWebImage 3.8.2">
<meta name="twitter:description" content="旧文章迁移自：简书 create by 2017.01.24 08:45 简单的介绍SDWebImage 提供图片的异步下载和缓存，对外通过 categories 封装 UIImageView ，UIButton，MKAnnotationView 的接口供使用者使用。SDWebImage 的磁盘缓存有对有效期和最大容量的限制处理，内存缓存在系统报内存警告的时候会清除。它还保障几个相同的 URL 不">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>阅读源代码：SDWebImage 3.8.2</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="https://github.com/al-liu">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/al-liu?tab=repositories">项目</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/04/09/Android-集成-Unity-环境遇到的一些坑/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/04/02/仿写有范儿-app/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&text=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&is_video=false&description=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=阅读源代码：SDWebImage 3.8.2&body=Check out this article: https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&name=阅读源代码：SDWebImage 3.8.2&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的介绍"><span class="toc-number">1.</span> <span class="toc-text">简单的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直观的感受"><span class="toc-number">2.</span> <span class="toc-text">直观的感受</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从‘头’开始"><span class="toc-number">3.</span> <span class="toc-text">从‘头’开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-和-Downloader-的管理者-SDWebImageManager"><span class="toc-number">4.</span> <span class="toc-text">Cache 和 Downloader 的管理者 SDWebImageManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片下载器-SDWebImageDownloader"><span class="toc-number">5.</span> <span class="toc-text">图片下载器 SDWebImageDownloader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作单元-SDWebImageDownloaderOperation"><span class="toc-number">6.</span> <span class="toc-text">操作单元 SDWebImageDownloaderOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片缓存-SDImageCache"><span class="toc-number">7.</span> <span class="toc-text">图片缓存 SDImageCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束"><span class="toc-number">8.</span> <span class="toc-text">结束</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        阅读源代码：SDWebImage 3.8.2
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">刘海川的技术博客</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-04-04T09:41:12.000Z" itemprop="datePublished">2019-04-04</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>旧文章迁移自：<a href="https://www.jianshu.com/u/06062b2fb381" target="_blank" rel="noopener">简书</a> create by 2017.01.24 08:45</p>
<h2 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><p>SDWebImage 提供图片的异步下载和缓存，对外通过 categories 封装 <code>UIImageView</code> ，<code>UIButton</code>，<code>MKAnnotationView</code> 的接口供使用者使用。<br>SDWebImage 的磁盘缓存有对有效期和最大容量的限制处理，内存缓存在系统报内存警告的时候会清除。它还保障几个相同的 URL 不会被重复下载，不可用的 URL 不会一次次的被重试，主线程绝不会被阻塞。</p>
<h2 id="直观的感受"><a href="#直观的感受" class="headerlink" title="直观的感受"></a>直观的感受</h2><p>SDWebImage 的接口简单易用，开发者一句代码就能使用，代码： <code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</code> ，复杂的逻辑和实现都被隐藏在这句代码的后面。<br>各模块独立，Cache缓存模块提供库的内存缓存和可选的磁盘缓存支持，Downloader下载模块提供基于 <code>NSURLSession</code> 和 <code>NSOperation</code> 的下载器。<code>SDWebImageManager</code> 则将 Cache 和 Downloader 两个模块很好的整合在一起，提供基于缓存的图片加载功能。最后是使用 categories 封装了常用 UI 控件的接口。<br>GitHub 上拥有万的 star，无数的使用者，在项目中久经考验，是程序猿学习的好材料。</p>
<h2 id="从‘头’开始"><a href="#从‘头’开始" class="headerlink" title="从‘头’开始"></a>从‘头’开始</h2><p>这个头就是最常用的类 <code>UIImageView+WebCache</code> ，类里面暴露了很多加载图片的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url;</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但是归根到底都是调用的这句，我们来看这里面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock；</span><br></pre></td></tr></table></figure>
<p>代码的第一句是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self sd_cancelCurrentImageLoad];</span><br></pre></td></tr></table></figure>
<p>看方法名就知道它的作用，就是<strong>取消这个视图 ImageView 正在加载图片的操作</strong>，如果这个 ImageView 正在加载图片，保障在开始新的加载图片任务之前，取消掉正在进行的加载操作。</p>
<p>看下具体的实现代码 <code>UIImageView+WebCache</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelCurrentImageLoad &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)sd_cancelCurrentAnimationImagesLoad &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewAnimationImages&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 key 说明有两个不一样的加载方式，一个是单张图片的，另一个是连续下载多张，放到 <code>NSArray&lt;UIImage *&gt; *animationImages</code> 中。</p>
<p>看下取消操作的代码实现，<code>UIView (WebCacheOperation)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    operations = [NSMutableDictionary dictionary];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    // Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    id operations = [operationDictionary objectForKey:key];</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中，通过 <code>objc_setAssociatedObject</code>  关联对象的方法，给 UIImageView 动态添加了一个 <code>NSMutableDictionary</code>  的属性。通过 key-value 维护这个 ImageView 已经有了哪些下载操作，如果是数组就是 <code>UIImageViewAnimationImages</code> 否则就是 <code>UIImageViewImageLoad</code> 。最后获得的都是遵从了 <code>&lt;SDWebImageOperation&gt;</code> 协议的对象，可以统一调用定义好的方法 cancel，达到取消下载操作的目的，如果 operation 都被取消了，则删除对应 key 的值。</p>
<p>继续看 <code>- (void)sd_setImageWithURL: placeholderImage: options: ;</code> 里的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        self.image = placeholder;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果加载图片的选项不是 <code>SDWebImageDelayPlaceholder</code> 则会在主线程中先设置 placeholder 的占位图， </p>
<p><code>SDWebImageDelayPlaceholder</code> 的情况后面说。<code>dispatch_main_async_safe</code> 是一个宏定义，我们可以参考这种写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_sync_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看起来很简洁。</p>
<p>下面这段就是这个类中比较关键的代码了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// check if activityView is enabled or not</span><br><span class="line">if ([self showActivityIndicatorView]) &#123;</span><br><span class="line">    [self addActivityIndicator];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak __typeof(self)wself = self;</span><br><span class="line">id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">    [wself removeActivityIndicator];</span><br><span class="line">    if (!wself) return;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        if (!wself) return;</span><br><span class="line">        if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">        &#123;</span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123;</span><br><span class="line">            wself.image = image;</span><br><span class="line">            [wself setNeedsLayout];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                wself.image = placeholder;</span><br><span class="line">                [wself setNeedsLayout];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">            completedBlock(image, error, cacheType, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br><span class="line">[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br></pre></td></tr></table></figure>
<p>先检查 activityView 是否可用，可用的话给 ImageView 正中间添加一个活动指示器，并旋转，加载图片完成或失败都会清除掉。<code>__weak __typeof(self)wself = self;</code> 避免循环引用，接下来就是调用 <code>SDWebImageManager</code> 的方法 <code>downloadImageWithURL: options: progress: completed:</code>  ，在该方法的 completed  block 回调中，如果 option 是 <code>SDWebImageAvoidAutoSetImage</code> ，就是要求不要给 ImageView 自动设置图片，则只回调 completedBlock 然后 return，否则有 image 就设置给 ImageView 。没有 image 通常就是错误情况，如果 option 是 <code>SDWebImageDelayPlaceholder</code> 则设置占位图（可以设置成提示用户图片没加载出来的图片），最后回调 completedBlock。上面代码最后一句是把这个 operation 存到 ImageView 的 <code>NSMutableDictionary</code> 中，为了之前提到的 <code>[self sd_cancelCurrentImageLoad];</code>  操作准备的。</p>
<p><code>UIImageView+WebCache</code> 类中的代码还是很容易的，逻辑很清晰，没有难懂的地方。接下来我们去看 <code>SDWebImageManager</code>  的核心方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<h2 id="Cache-和-Downloader-的管理者-SDWebImageManager"><a href="#Cache-和-Downloader-的管理者-SDWebImageManager" class="headerlink" title="Cache 和 Downloader 的管理者 SDWebImageManager"></a>Cache 和 Downloader 的管理者 SDWebImageManager</h2><p>我们看这个方法前几句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&apos;t</span><br><span class="line">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中说 <code>NSString</code> 替换 <code>NSURL</code> 做为参数传进来是很常见的错误，但奇怪的是 XCode 没有类型错误的警告。这个我试过是有警告提示的，可能更早一些的 XCode 版本是这样的。这几句就是参数的校验，没什么好说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation = operation;</span><br></pre></td></tr></table></figure>
<p>这个类的作用是管理多个模块的取消操作，具体是怎么实现的，后面的代码会提到，<code>__weak</code> 修饰是为了防止循环引用。</p>
<p>下面就是文章最开始提到的功能之一，不可用的 URL 不会一次次重试的功能实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL isFailedUrl = NO;</span><br><span class="line">@synchronized (self.failedURLs) &#123;</span><br><span class="line">    isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 downloader 的下载方法的 completedBlock 中会将下载失败的 URL ，维护到 Set 集合中（黑名单），代码会在后面提到。这段代码的意思是如果发现 url 长度为 0 ，或者是下载失败过的 url ，且没有要求重试则直接创建 <code>NSError</code> 并 回调 completedBlock 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>manager 维护了一个数组 <code>self.runningOperations</code> ，将所有操作放进去，便于管理。（比如统一调用 cancel ）</p>
<p>下面是比较核心的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过 url 获取用来缓存的 key，尝试去缓存中取图片。<code>queryDiskCacheForKey: done:</code> 方法返回了一个 <code>NSOperation</code> 对象并赋值给了 <code>SDWebImageCombinedOperation</code> 的 <code>cacheOperation</code> ，这个类（SDWebImageCombinedOperation）中还有一个属性 <code>cancelBlock</code> 也会包括一些取消操作。它还实现了协议 <code>&lt;SDWebImageOperation&gt;</code> ，这个协议里只需要实现一个方法，就是 <code>- (void)cancel;</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>而 <code>SDWebImageCombinedOperation</code> 的实现类中，实现了这个 cancel 方法，并调用了这些取消操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    self.cancelled = YES;</span><br><span class="line">    if (self.cacheOperation) &#123;</span><br><span class="line">        [self.cacheOperation cancel];</span><br><span class="line">        self.cacheOperation = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.cancelBlock) &#123;</span><br><span class="line">        self.cancelBlock();</span><br><span class="line">        </span><br><span class="line">        // TODO: this is a temporary fix to #809.</span><br><span class="line">        // Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span><br><span class="line">//        self.cancelBlock = nil;</span><br><span class="line">        _cancelBlock = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，调用者只要调用 operation 的 <code>cancel()</code> ，就可以统一对多个模块类做取消操作。</p>
<p>然后看下查询缓存的方法  <code>- (NSOperation *)queryDiskCacheForKey: done:</code>  的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会先到内存缓存中去查找，如果命中则直接回调，没有命中继续在磁盘缓存中查找。查找任务是异步的，在一个串行队列中，先生成一个 <code>NSOperation</code> 对象返回，也就是赋值给了 <code>operation.cacheOperation</code> 。在查找任务中，会先检测这个 operation 有没有被取消，如果取消则直接 return，这就实现了 <code>SDWebImageCombinedOperation</code> 可以取消查找缓存的操作。之后的代码就是去磁盘缓存中查找图片，且如果需要内存缓存就存进去，最后回调 doneBlock。这段代码被放入到了 @autoreleasepool 中包裹起来，是因为查找出来的图片可能会比较大，占用较多的内存，保障能够及时的回收它。关于 @releasepool 的原理参考<a href="http://draveness.me/autoreleasepool/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>现在回到 <code>SDWebImageManager</code> 中继续看，在 <code>queryDiskCacheForKey:</code> 的 doneBlock 中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (operation.isCancelled) &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations removeObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果操作被取消，则删除掉 <code>self.runningOperations</code> 的操作，然后 return。</p>
<p>接下来会有三个条件分支，我们一个个来看，第一个是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>image 为空意味着缓存没有命中，<code>SDWebImageRefreshCached</code> 则是就算缓存命中也要下载图片更新缓存，<code>SDWebImageManager</code> 这个类还定义了一个协议并实现一个代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>第一个方法的意思是，是否下载图片，YES 就是下载，NO 就是不下载。第二个方法是，对下载好的图片 image 做 transform 处理，比如可以改成圆角图片等，然后返回，这样缓存的图片也会是 transform 之后的图片。<br>理解了代理方法的意思就可以理解这个条件了，如果缓存没有命中，或需要刷新已有缓存 且 没有实现 <code>imageManager:shouldDownloadImageForURL</code> 的方法（默认是 YES，可以下载图片）则去下载图片。如果实现了这个代理方法返回的是 YES，也会去下载图片。</p>
<p>看第一个条件里的代码，首先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">        // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">        completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存如果命中，且需要更新缓存，则先将缓存图片通过 completedBlock 回调出去，在继续下载图片。</p>
<p>在往下就是缓存没有命中或需要更新缓存的情况，所以需要下载图片，但之前先将 <code>SDWebImageManager</code> 里 option 的条件映射成 <code>SDWebImageDownloder</code> 里的 option 的条件，下载使用的方法是 <code>SDWebImageDownloder</code> 里的 <code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</code> 方法。具体实现我们在分析 <code>SDWebImageDownloder</code>  时会说，先看 completedBlock 里的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">    // Do nothing if the operation was cancelled</span><br><span class="line">    // See #699 for more details</span><br><span class="line">    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意避免循环引用，<code>imageDownloader</code> 被 <code>SDWebImageManager</code> 强引用，<code>downloadImageWithURL</code> 的 completedBlock 会被 <code>imageDownloader</code> 的属性 <code>URLCallbacks</code>  数组强引用保存起来，至于为什么这么做后面会讲到。</p>
<p>然后是发生错误的处理情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">else if (error) &#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">        @synchronized (self.failedURLs) &#123;</span><br><span class="line">            [self.failedURLs addObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生错误，并回调。将在确定条件下失败的 URL 放入黑名单，不会反复请求。（通常是 URL 的问题，而不是网络问题）</p>
<p>看下 else 之后的代码，稍长一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">        @synchronized (self.failedURLs) &#123;</span><br><span class="line">            [self.failedURLs removeObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">    &#125;</span><br><span class="line">    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 option 是 <code>SDWebImageRetryFailed</code> 则这个 url 从黑名单中删除，给它一个重试的机会。有 <code>downloadedImage</code> 说明图片下载成功，如果是要进行 transform ，则调用 delegate 方法，获取 transform 之后的图片，进行缓存，再调用 completedBlock 。如果不需要 transform 则直接缓存后回调 completedBlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">operation.cancelBlock = ^&#123;</span><br><span class="line">    [subOperation cancel];</span><br><span class="line">    </span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        if (strongOperation) &#123;</span><br><span class="line">            [self.runningOperations removeObject:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是下载图片的取消操作，调用 NSOperation 的 cancel，从 <code>self.runningOperations</code> 中删除 operation。赋值给 cancelBlock ，交给 <code>SDWebImageCombinedOperation</code> 对象管理。</p>
<p>看前面提到的三个分支条件的第二个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">else if (image) &#123;</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">            completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations removeObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有 image 说明缓存命中，且没有要重下图片的情况，则直接回调 completedBlock 就可以了。</p>
<p>第三个分支条件，它的意思是既没有缓存图片，代理 delegate 也不允许下载图片，那就只能直接回调 completedBlock ，图片参数传 nil 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    // Image not in cache and download disallowed by delegate</span><br><span class="line">    dispatch_main_sync_safe(^&#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">            completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations removeObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，<code>SDWebImageManager</code> 的核心方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>就介绍完了。</p>
<h2 id="图片下载器-SDWebImageDownloader"><a href="#图片下载器-SDWebImageDownloader" class="headerlink" title="图片下载器 SDWebImageDownloader"></a>图片下载器 SDWebImageDownloader</h2><p>我们还是从 <code>SDWebImageDownloader</code> 的核心方法入手：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>该方法的大部分代码都放到了一个 createCallback 的回调中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line"></span><br><span class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们只能先去探究下 <code>- (void)addProgressCallback: completedBlock: forURL: createCallback: ;</code> 这个方法，它的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">if (url == nil) &#123;</span><br><span class="line">    if (completedBlock != nil) &#123;</span><br><span class="line">        completedBlock(nil, nil, nil, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">    BOOL first = NO;</span><br><span class="line">    if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">        self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">        first = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle single download of simultaneous download request for the same URL</span><br><span class="line">    NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">    NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    [callbacksForURL addObject:callbacks];</span><br><span class="line">    self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">    if (first) &#123;</span><br><span class="line">        createCallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注释有说，这个 URL 参数不能为空，因为它要作为存储 callbacks 字典的 key，如果它为 nil 则会马上调用 completed block 返回 nil 图片和 nil 数据。<br><code>self.URLCallbacks</code> 是一个 <code>NSMutableDictionary</code> ，它以 URL 作为 key ，维护一个可变数组 <code>callbacksForURL</code>，这个数组里又会存放一个一个的  <code>NSMutableDictionary</code>  用来存储两个 callback 回调方法，分别是以 <code>kProgressCallbackKey</code> 为 key 的 <code>progressBlock</code>  和 以 <code>kCompletedCallbackKey</code>  为 key 的 <code>completedBlock</code> 。代码里还有一个 <code>BOOL first</code> 的变量，如果发现 <code>self.URLCallbacks</code> 中没有这个 URL 的回调数组，那这个 URL 此时就是第一次请求（此时没有相同的 URL 在请求），会调用 <code>createCallback();</code> 来创建下载的操作，而发现  <code>self.URLCallbacks</code> 中有这个 URL 的回调数组的话，则将对应的那两个回调方法存进 <code>NSMutableDictionary</code> ，在放到之前的回调数组中，且不会再调用 <code>createCallback();</code> ，这样相同的 URL 不会重复请求下载。当第一个请求下载成功之后，会遍历这个回调数组，将数组里所有的 callback 都执行一遍。这么做的目的就是防止同时有多个相同 URL 的请求发生。<br>这段代码使用 <code>dispatch_barrier_sync</code> 将任务放入一个并发队列，目的是在并发队列中，这个任务执行时，不允许别的任务同时执行。因为 <code>downloadImageWithURL:</code> 方法要返回一个遵从<code>&lt;SDWebImageOperation&gt;</code> 的对象，所以要同步执行而不能异步。</p>
<p>现在就可以看一看 <code>createCallback();</code> 中到底都做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">if (timeoutInterval == 0.0) &#123;</span><br><span class="line">    timeoutInterval = 15.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.HTTPShouldUsePipelining = YES;</span><br><span class="line">if (wself.headersFilter) &#123;</span><br><span class="line">    request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">&#125;</span><br><span class="line">operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                inSession:self.session</span><br><span class="line">                                                  options:options</span><br><span class="line">                                                 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                     SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                     if (!sself) return;</span><br><span class="line">                                                     __block NSArray *callbacksForURL;</span><br><span class="line">                                                     dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                         callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                     &#125;);</span><br><span class="line">                                                     for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                         dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                             SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                             if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                         &#125;);</span><br><span class="line">                                                     &#125;</span><br><span class="line">                                                 &#125;</span><br><span class="line">                                                completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                    SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                    if (!sself) return;</span><br><span class="line">                                                    __block NSArray *callbacksForURL;</span><br><span class="line">                                                    dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                        callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                        if (finished) &#123;</span><br><span class="line">                                                            [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;);</span><br><span class="line">                                                    for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                        SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                        if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                cancelled:^&#123;</span><br><span class="line">                                                    SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                    if (!sself) return;</span><br><span class="line">                                                    dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                        [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                    &#125;);</span><br><span class="line">                                                &#125;];</span><br><span class="line">operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">if (wself.urlCredential) &#123;</span><br><span class="line">    operation.credential = wself.urlCredential;</span><br><span class="line">&#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">    operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">    operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">&#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">    operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[wself.downloadQueue addOperation:operation];</span><br><span class="line">if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">    [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">    wself.lastAddedOperation = operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建了 <code>NSMutableURLRequest</code> 请求对象，然后调用 <code>SDWebImageDownloaderOperation</code> （继承 NSOperation）的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithRequest:(NSURLRequest *)request</span><br><span class="line">            inSession:(NSURLSession *)session</span><br><span class="line">              options:(SDWebImageDownloaderOptions)options</span><br><span class="line">             progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">            completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">            cancelled:(SDWebImageNoParamsBlock)cancelBlock;</span><br></pre></td></tr></table></figure>
<p>在 progressBlock 的回调方法里，会通过 <code>sself.URLCallbacks</code> 取出这个 URL 所有 <code>kProgressCallbackKey</code> 的回调方法，并将获取到的 <code>receivedSize</code> 和 <code>expectedSize</code> 的值传入这些方法中调用。<br>在 completedBlock 的回调方法里和 progressBlock 中的一样，取出 <code>kCompletedCallbackKey</code> 对应的回调方法，将获取到的 image ，data，error，finished 的值传入方法中调用，还会删除 <code>sself.URLCallbacks</code> 中这个 URL 的回调数组 ，保障这个 URL 下次可以重新创建新请求。<br>在 cancelBlock 中则只是删除掉  <code>sself.URLCallbacks</code> 中这个 URL 的回调数组。<br>在往下是，给 operation 设置是否应该解压图片的属性，解压图片会提高下载和缓存的性能，但是会消耗较多的内存，如果程序因为占用内存过多而闪退则要把这个属性设置成 NO。<br>设置 operation 请求的 <code>NSURLCredential</code> ，用于在请求过程中，服务端要求验证客户端的凭证  <code>- (void)URLSession: task: didReceiveChallenge: completionHandler:</code>  。<br>再往后，是设置 NSOperation 的操作优先级。<code>[wself.downloadQueue addOperation:operation];</code> 是将操作任务加到 <code>NSOperationQueue</code> 队列中，开始任务。最后是设置操作的执行顺序，默认是 FIFO 的先进先出的模式，也可以改成 LIFO 后进先出的栈模式，实现的方法就是添加依赖，前面的操作依赖后面的操作。设置完之后，则 return 这个 operation。<br>到此，<code>SDWebImageDownloader</code> 的这个核心方法就介绍完了。<br>还有一点，下载的请求是使用的 <code>NSURLSession</code> ，<code>SDWebImageDownloader</code> 将  <code>NSURLSession</code> 的 delegate 设置成自己，统一接收这些回调方法。在这些回调方法中，会返回一个 <code>NSURLSessionDataTask</code> 通过这个 dataTask 的 <code>taskIdentifier</code> ，我们就可以在 <code>self.downloadQueue.operations</code> 中找到回调方法对应的 operation （<code>SDWebImageDownloaderOperation</code>），每个 operation 中都有这些代理方法，这样在 <code>SDWebImageDownloader</code> 统一接收的回调中用找到的 operation 调用当前的这个代理方法，把参数传到对应的 operation 中。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (SDWebImageDownloaderOperation *)operationWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    for (SDWebImageDownloaderOperation *operation in self.downloadQueue.operations) &#123;</span><br><span class="line">        if (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnOperation;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line"></span><br><span class="line">    [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> <code>SDWebImageDownloaderOperation</code>  的 <code>- (id)initWithRequest:(NSURLRequest *)request inSession: options: progress: completed: cancelled:;</code> 是下载图片的关键代码，下面就来看下 <code>SDWebImageDownloaderOperation</code> 这个类。</p>
<h2 id="操作单元-SDWebImageDownloaderOperation"><a href="#操作单元-SDWebImageDownloaderOperation" class="headerlink" title="操作单元 SDWebImageDownloaderOperation"></a>操作单元 SDWebImageDownloaderOperation</h2><p><code>SDWebImageDownloaderOperation</code> 继承自     <code>NSOperation</code> ，并且实现了 <code>&lt;SDWebImageOperation, NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</code> 这三个协议。继承     <code>NSOperation</code> 的子类执行任务的代码都写在 <code>- (void)start;</code> 或者 <code>- (void)main;</code> 中，我们就从 <code>SDWebImageDownloaderOperation</code> 重写的 <code>- (void)start;</code> 方法入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是，如果程序进入后台会给程序一段时间，完成未完成的任务，如果时间到了任务还是没有完成则取消这个任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *session = self.unownedSession;</span><br><span class="line">if (!self.unownedSession) &#123;</span><br><span class="line">    NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     *  Create the session for this task</span><br><span class="line">     *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">     *  method calls and completion handler calls.</span><br><span class="line">     */</span><br><span class="line">    self.ownedSession = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                      delegate:self</span><br><span class="line">                                                 delegateQueue:nil];</span><br><span class="line">    session = self.ownedSession;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.dataTask = [session dataTaskWithRequest:self.request];</span><br><span class="line">self.executing = YES;</span><br><span class="line">self.thread = [NSThread currentThread];</span><br></pre></td></tr></table></figure>
<p><code>self.unownedSession</code> 是从 <code>SDWebImageDownloader</code> 中传进来的，而如果没有传进来 <code>self.unownedSession</code> 则自己创建一个 <code>self.ownedSession</code>，这个 <code>self.ownedSession</code> 设置的代理是自己，回调的代理方法直接调用这个类里的， 而<code>self.unownedSession</code>  传进来的这种，代理方法就是通过上面介绍过的方式调用到这个类的。上面注释的意思是为 task 创建一个 session，delegateQueue 中传入一个 nil，这样 session 就会创建一个串行的操作队列来执行所有的代理方法和完成处理的调用。<br>继续看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[self.dataTask resume];</span><br><span class="line"></span><br><span class="line">if (self.dataTask) &#123;</span><br><span class="line">    if (self.progressBlock) &#123;</span><br><span class="line">        self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    if (self.completedBlock) &#123;</span><br><span class="line">        self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resume 开启这个任务，调用下 <code>self.progressBlock</code> 传入初始的值，然后在主线程发送一个开始下载的通知，如果没有 <code>self.dataTask</code> 则调用 <code>self.completedBlock</code> 返回一个 <code>NSError</code> 。</p>
<p>下面我们在简单说下 <code>SDWebImageDownloaderOperation</code> 类中这两个 <code>NSURLSessionTaskDelegate</code> 和 <code>NSURLSessionDataDelegate</code>  协议的代理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</span><br></pre></td></tr></table></figure>
<p>在这个方法里检查下 response 的状态码，不正确的话取消任务，completedBlock 回调 <code>NSError</code> 。正确的话，获取下载数据的总大小 <code>expectedContentLength</code> ，并调用 <code>self.progressBlock</code> 。还会创建保存数据流的 <code>NSMutableData</code> 对象，<code>self.imageData = [[NSMutableData alloc] initWithCapacity:expected];</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</span><br></pre></td></tr></table></figure>
<p>将每次接收到的数据 data 拼接到之前创建好的 <code>self.imageData</code> 中去，<code>[self.imageData appendData:data];</code> 。如果 option 的要求是 <code>SDWebImageDownloaderProgressiveDownload</code> 则在这里把已有的数据 <code>self.imageData</code> 转成 image ，通过 self.completedBlock 回调出去，注意 finished 参数是 NO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.progressBlock) &#123;</span><br><span class="line">    self.progressBlock(self.imageData.length, self.expectedSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>self.progressBlock</code> 将下载进度回调出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error;</span><br></pre></td></tr></table></figure>
<p>请求完成的回调方法，有 error 则 <code>self.completedBlock(nil, nil, error, YES);</code> ，没有则将 <code>self.imageData</code> 转成 image 回调出去 <code>completionBlock(image, self.imageData, nil, YES);</code> ，当然这里面涉及很多处理的细节和其他情况的判断，就先不说了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;</span><br></pre></td></tr></table></figure>
<p>这段则是针对不同的鉴定场景返回不一样的策略。</p>
<p>至此，<code>SDWebImageDownloaderOperation</code> 中的这些代理方法就简单的介绍完了。</p>
<h2 id="图片缓存-SDImageCache"><a href="#图片缓存-SDImageCache" class="headerlink" title="图片缓存 SDImageCache"></a>图片缓存 SDImageCache</h2><p><code>SDImageCache</code> 包括内存缓存和磁盘缓存，内存缓存使用的是继承自 <code>NSCache</code> 的 <code>AutoPurgeCache</code> ，而磁盘缓存就是基于文件的读写。<br>先查看 <code>SDImageCache</code> 的接口，看下都包括哪些功能，然后一一讲解代码。<br>存储的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image forKey:(NSString *)key;</span><br><span class="line">- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;</span><br><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk;</span><br><span class="line">- (void)storeImageDataToDisk:(NSData *)imageData forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>这四个方法的前两个直接调用的第三个，所以我们从第三个方法入手。<br>看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// if memory cache is enabled</span><br><span class="line">if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">    NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">    [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内存缓存可用，就将图片通过 <code>NSCache</code> 的接口 <code>- (void)setObject: forKey: cost: ;</code> 存入。计算 cost 的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是一张图片的像素数量。<br>如果需要存入磁盘，一般情况下我们是将 imageData 直接存入的，但是如果 <code>recalculate</code> 的值是 YES ，或者没有 imageData，那我们就需要将 image 转成 <code>NSData</code> 存入磁盘。具体的实现是判断这个 image 有没有透明通道或者它的前八个字节是不是规定的 PNG 那固定的八个字节，如果是则就调用 <code>UIImagePNGRepresentation</code> 方法转成 <code>NSData</code> ，如果不是那就调用 <code>UIImageJPEGRepresentation</code> 这个方法。有了 data 之后，就要调用那四个存储方法的第四个 <code>storeImageDataToDisk</code> 。<br>通过 key 和 <code>_diskCachePath</code> 得到缓存文件的具体路径，在使用 <code>NSFileManager</code> 中 <code>- (BOOL)createFileAtPath: contents: attributes: ;</code> 方法，将数据写入磁盘中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// disable iCloud backup</span><br><span class="line">    if (self.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是避免该文件被 iCloud 备份。<br>这些读写操作都放到了 <code>SDImageCache</code> 的一个串行队列中，<code>ioQueue</code> 。我觉得是因为 <code>_fileManager</code> 是自己创建的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">    _fileManager = [NSFileManager new];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>是为了保障它的线程安全，在 <code>SDImageCache</code> 这个类的所有文件读写操作，都会放到 <code>ioQueue</code> 这个队列执行。而 <code>[NSFileManager defaultManager]</code> 是系统提供，本身就是线程安全的。</p>
<p>查询的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock;</span><br><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;</span><br><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>第一个查询方法，在讲 <code>SDWebImageManager</code> 时已经讲过了。<br>第二个方法，就是调用的 <code>NSCache</code> 中的 <code>- (nullable ObjectType)objectForKey:</code> 的方法。<br>第三个方法中，会先到内存缓存去查找，如果没有命中，则去磁盘缓存中查找，大概就是通过 key 获取具体的路径找到对应的文件取出 <code>NSData</code> ，在经过一些处理转成 image 返回。</p>
<p>删除的功能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeImageForKey:(NSString *)key;</span><br><span class="line">- (void)removeImageForKey:(NSString *)key withCompletion:(SDWebImageNoParamsBlock)completion;</span><br><span class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk;</span><br><span class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</span><br></pre></td></tr></table></figure>
<p>前三个方法都是调用的第四个，所以我们看第四个方法就好了。<br>如果有内存缓存则调用 <code>NSCache</code> 中的 <code>- (void)removeObjectForKey:</code> ，如果 <code>fromDisk</code> 为 YES，则调用 <code>NSFileManager</code> 的 <code>- (BOOL)removeItemAtPath: error:</code> 方法，删除指定缓存文件的路径即可。</p>
<p>清除的功能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearMemory;</span><br><span class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion;</span><br><span class="line">- (void)clearDisk;</span><br></pre></td></tr></table></figure>
<p>第一个方法直接调用 <code>NSCache</code> 的 <code>- (void)removeAllObjects;</code> 。第二个方法，直接调用了 <code>NSFileManager</code> 的 <code>- (BOOL)removeItemAtPath: error:</code>  删除指定缓存目录的路径即可。第三个方法调用的第二个方法。</p>
<p>清理的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;</span><br><span class="line">- (void)cleanDisk;</span><br></pre></td></tr></table></figure>
<p>清理缓存就是清理掉一些过期的文件和超最大缓存大小限制的文件。<br>看第一个方法，首先获取磁盘缓存的路径 URL。然后通过以下代码获取所有缓存文件的一些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">// This enumerator prefetches useful properties for our cache files.</span><br><span class="line">NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                           includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                              options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                         errorHandler:NULL];</span><br></pre></td></tr></table></figure>
<p>这些属性分别是，是否是目录，文件的修改日期和文件大小。<br><code>NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</code>  这一句则是获取缓存过期的日期。<br>然后 for-in 遍历 <code>fileEnumerator</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">    NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];</span><br><span class="line"></span><br><span class="line">    // Skip directories.</span><br><span class="line">    if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remove files that are older than the expiration date;</span><br><span class="line">    NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">    if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">        [urlsToDelete addObject:fileURL];</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Store a reference to this file and account for its total size.</span><br><span class="line">    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">    currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">    [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取文件路径的属性字典，如果是目录则跳过，比较修改日期和过期日期哪个更晚一些，如果是过期日期则说明该文件过期，放入 <code>urlsToDelete</code> 数组中。将文件大小累加到 <code>currentCacheSize</code> 上，并将不是过期的这些缓存文件记录到 <code>cacheFiles</code> 中，key 是文件的 URL ，value 是对应的属性字典。<br>之后，遍历 <code>urlsToDelete</code> 数组删除这些过期文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">    [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，判断没有过期的这些文件的总大小有没有超过最大的缓存大小 <code>self.maxCacheSize</code> 。<br>如果有的话，将 <code>cacheFiles</code> 里的 value 按照文件的修改日期进行排序，返回一个排好序的数组。取 <code>self.maxCacheSize</code> 大小的一半，作为清理缓存的界限 <code>const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</code>。遍历排序后的数组，一个个文件删除，删除一个就从之前的总缓存文件大小的值减去删除后的文件大小，再比较有没有小于清理缓存的界限值 <code>desiredCacheSize</code>。如果小于了，则跳出循环。最后在主线程回调 <code>completionBlock();</code> 。这样就达到了清理磁盘缓存的目的。</p>
<p>计算缓存大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize;</span><br><span class="line">- (NSUInteger)getDiskCount;</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(SDWebImageCalculateSizeBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p>第一个方法就是遍历缓存目录的所有文件，获取这些文件路径，通过 <code>[[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil]</code> 获得一个字典在通过 fileSize 方法获取文件大小，累加起来就是缓存的大小。<br>第二个和第三个方法都是获取指定缓存路径的 <code>NSDirectoryEnumerator</code> 遍历取对应的值，和上面相差不大，不在赘述。</p>
<p>查询缓存是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsWithKey:(NSString *)key completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line">- (BOOL)diskImageExistsWithKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<p>这些方法的实现基本就是调用 <code>exists = [[NSFileManager defaultManager] fileExistsAtPath:[self defaultCachePathForKey:key]];</code> 这个方法，不在赘述。</p>
<p>最后说下 <code>clearMemory</code> ，<code>cleanDisk</code> ，<code>backgroundCleanDisk</code> 的调用时机，在 <code>- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory{}</code> 这个初始化方法中，注册了三个通知分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(clearMemory)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(cleanDisk)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(backgroundCleanDisk)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure>
<p>报内存警告时调用 <code>clearMemory</code> 清除内存缓存，程序即将终止的时候调用 <code>cleanDisk</code> 清理过期或超大小限制的磁盘缓存，而程序进入后台的时候，调用 <code>backgroundCleanDisk</code> ，在后台执行 <code>cleanDiskWithCompletionBlock</code> 清理任务。</p>
<p>至此，<code>SDImageCache</code> 的大部分方法就讲解完了。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p><code>SDWebImage</code> 这个库的基本思路就说完了，其实里面还有诸多的细节需要学习，比如图片处理，性能优化，内存管理等。阅读优秀的开源代码，会有一种探索的乐趣，不论从大的整体结构还是小的实现细节上，都能学到很多东西。</p>

  </div>
</article>



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script src="../../source/js/md5.min.js"></script>
    <div id="gitalk-container"></div>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: '46f9862d762f2b91e265',
            clientSecret: 'b1a5c3d47828b1c1ab0b25081463e2b94f132245',
            id: md5(window.location.pathname),
            repo: 'al-liu.github.io',
            owner: 'al-liu',
            admin: 'al-liu',
            distractionFreeMode: ''
        })
        gitalk.render('gitalk-container')
    </script>




        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="https://github.com/al-liu">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/al-liu?tab=repositories">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单的介绍"><span class="toc-number">1.</span> <span class="toc-text">简单的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直观的感受"><span class="toc-number">2.</span> <span class="toc-text">直观的感受</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从‘头’开始"><span class="toc-number">3.</span> <span class="toc-text">从‘头’开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-和-Downloader-的管理者-SDWebImageManager"><span class="toc-number">4.</span> <span class="toc-text">Cache 和 Downloader 的管理者 SDWebImageManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片下载器-SDWebImageDownloader"><span class="toc-number">5.</span> <span class="toc-text">图片下载器 SDWebImageDownloader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作单元-SDWebImageDownloaderOperation"><span class="toc-number">6.</span> <span class="toc-text">操作单元 SDWebImageDownloaderOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图片缓存-SDImageCache"><span class="toc-number">7.</span> <span class="toc-text">图片缓存 SDImageCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束"><span class="toc-number">8.</span> <span class="toc-text">结束</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&text=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&is_video=false&description=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=阅读源代码：SDWebImage 3.8.2&body=Check out this article: https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&title=阅读源代码：SDWebImage 3.8.2"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://github.com/al-liu/2019/04/04/阅读源代码：SDWebImage-3-8-2/&name=阅读源代码：SDWebImage 3.8.2&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 刘海川 al-liu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="https://github.com/al-liu">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/al-liu?tab=repositories">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
